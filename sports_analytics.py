"""
Sports Analytics
"""

import numeric
import codeskulptor
from urllib import request
import comp140_module6 as sports
import math

def read_matrix(filename):
    """
    Parse data from the file with the given filename into a matrix.

    input:
        - filename: a string representing the name of the file

    returns: a matrix containing the elements in the given file
    """
    

    url = codeskulptor.file2url(filename)
    netfile = request.urlopen(url)
    mat_a = []
    for line in netfile.readlines():
        str_line = line.decode('utf-8')
        #convert from type to string
        rows = str_line.split(", ")
        for idx in range(len(rows)):
            rows[idx] = float(rows[idx])
            #convert to float 
        mat_a.append(rows)
    
    file_matrix = numeric.Matrix(mat_a)
    
    return file_matrix

         
class LinearModel:
    """
    A class used to represent a Linear statistical
    model of multiple variables. This model takes
    a vector of input variables and predicts that
    the measured variable will be their weighted sum.
    """

    def __init__(self, weights):
        """
        Create a new LinearModel.

        inputs:
            - weights: an m x 1 matrix of weights
        """
        self._weights = weights

    def __str__(self):
        """
        Return: weights as a human readable string.
        """
        return str(self._weights)

    def get_weights(self):
        """
        Return: the weights associated with the model.
        """
        return self._weights

    def generate_predictions(self, inputs):
        """
        Use this model to predict a matrix of
        measured variables given a matrix of input data.

        inputs:
            - inputs: an n x m matrix of explanatory variables

        Returns: an n x 1 matrix of predictions
        """
        prediction = inputs @ self._weights
        return prediction

    def prediction_error(self, inputs, actual_result):
        """
        Calculate the MSE between the actual measured
        data and the predictions generated by this model
        based on the input data.

        inputs:
            - inputs: inputs: an n x m matrix of explanatory variables
            - actual_result: an n x 1 matrix of the corresponding
                             actual values for the measured variables

        Returns: a float that is the MSE between the generated
        data and the actual data
        """
        prediction = self.generate_predictions(inputs)
        rows = prediction.shape()[0]
        sum_n = 0
        for row_idx in range(rows):
            sum_n += (actual_result[(row_idx, 0)]-prediction[(row_idx, 0)])**2
    
        meanse = sum_n/rows
        return meanse
       

def fit_least_squares(input_data, output_data):
    """
    Create a Linear Model which predicts the output vector
    given the input matrix with minimal Mean-Squared Error.

    inputs:
        - input_data: an n x m matrix
        - output_data: an n x 1 matrix

    returns: a LinearModel object which has been fit to approximately
    match the data
    """
    opt_wt1 = output_data.transpose() @ input_data 
    opt_wt2 = (input_data.transpose() @ input_data).inverse()
    opt_wt_mat = (opt_wt1 @ opt_wt2).transpose()
    opt_wt = LinearModel(opt_wt_mat)
    return opt_wt

def soft_threshold(x_val, t_val):
    """
    Moves x closer to 0 by the distance t.
    If this would move x past 0, the value is simply 0
    
    inputs: 
        - x_val: initial value
        - t_val: the distance t that x wil move
        
    returns: x after having moved a distance t
    """
    if x_val > t_val:
        soft_x = x_val - t_val
    elif abs(x_val) <= t_val:
        soft_x = 0
    elif x_val < t_val:
        soft_x = x_val + t_val
    return soft_x

def fit_lasso(param, iterations, input_data, output_data):
    """
    Create a Linear Model which predicts the output vector
    given the input matrix using the LASSO method.

    inputs:
        - param: a float representing the lambda parameter
        - iterations: an integer representing the number of iterations
        - input_data: an n x m matrix
        - output_data: an n x 1 matrix

    returns: a LinearModel object which has been fit to approximately
    match the data
    """


    weight = fit_least_squares(input_data, output_data).get_weights()
    count = 0
    x_col = input_data.shape()[1]
    x_transpose = input_data.transpose()
    x_t_y = x_transpose @ output_data 
    x_t_x = x_transpose @ input_data                                          
    
    while count < iterations:
        previous_weight = weight.copy() 
        #need to copy weight
        for row in range(x_col):
            a_val1 = (x_t_y)[(row,0)] 
            a_val2 = ((x_t_x).getrow(row) @ weight)[(0,0)]
            a_val_d = (x_t_x)[(row,row)]
            a_val = (a_val1 - a_val2) / a_val_d
            b_val = param / (2 * (x_t_x)[(row,row)])
            weight[(row,0)] = soft_threshold(weight[(row,0)] + a_val, b_val)

        if ((weight - previous_weight).abs().summation()) < 10**(-5):
            break
        count += 1
    lasso_fit_wt = LinearModel(weight)
    return lasso_fit_wt


def run_experiment(iterations):
    """
    Using some historical data from 1954-2000, as
    training data, generate weights for a Linear Model
    using both the Least-Squares method and the
    LASSO method (with several different lambda values).

    Test each of these models using the historical
    data from 2001-2012 as test data.

    inputs:
        - iterations: an integer representing the number of iterations to use

    Print out the model's prediction error on the two data sets
    """
    training_matrix = read_matrix("comp140_analytics_baseball.txt")
    wins1954_matrix = read_matrix("comp140_analytics_wins.txt")
    
    least_square_model = fit_least_squares(training_matrix, wins1954_matrix)
    
    lasso_model_lamda1 = fit_lasso(1000, iterations, training_matrix, wins1954_matrix)
    lasso_model_lamda2 = fit_lasso(10000, iterations, training_matrix, wins1954_matrix)
    lasso_model_lamda3 = fit_lasso(100000, iterations, training_matrix, wins1954_matrix)
    
    lse_p_error = least_square_model.prediction_error(training_matrix, wins1954_matrix)
    lasso_p_error_1000 = lasso_model_lamda1.prediction_error(training_matrix, wins1954_matrix)
    lasso_p_error_10000 = lasso_model_lamda2.prediction_error(training_matrix, wins1954_matrix)
    lasso_p_error_100000 = lasso_model_lamda3.prediction_error(training_matrix, wins1954_matrix)
    
    print("LSE model on 1954-2000: ", lse_p_error)
    print("LASSO model on 1954-2000 with lamda 1000: ", lasso_p_error_1000)
    print("LASSO model on 1954-2000 with lamda 10000: ", lasso_p_error_10000)
    print("LASSO model on 1954-2000 with lamda 100000: ", lasso_p_error_100000)
    
    #test
    data2001_matrix = read_matrix("comp140_analytics_baseball_test.txt")
    wins2001_matrix = read_matrix("comp140_analytics_wins_test.txt")
    
    lse_p_error2001 = least_square_model.prediction_error(data2001_matrix, wins2001_matrix)
    lasso_p_error2001_1000 = lasso_model_lamda1.prediction_error(data2001_matrix, wins2001_matrix)
    lasso_p_error2001_10000 = lasso_model_lamda2.prediction_error(data2001_matrix, wins2001_matrix)
    lasso_p_error2001_100000 = lasso_model_lamda3.prediction_error(data2001_matrix, wins2001_matrix)
    
    print("LSE model on 2001-2012: ", lse_p_error2001)
    print("LASSO model on 2001-2012 with lamda 1000: ", lasso_p_error2001_1000)
    print("LASSO model on 2001-2012 with lamda 10000: ", lasso_p_error2001_10000)
    print("LASSO model on 2001-2012 with lamda 100000: ", lasso_p_error2001_100000)
    
    
    
run_experiment(70)
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
